* Javascript код, встраиваемый в дерево ui элементов.

Прежде всего важно понять, что этот код исполняется на стороне бэкенда ui, поэтому не имеет доступа ни до чего, кроме возможностей ui.
Этот код может находиться _только_ в методе code `action_object`ов

api экспортируется в метод код с помощью специальной фукнции-прокси - ui.

** Виды api

Для кода доступны следующие виды программных интерфейсов:
+ `ui` -
  модификация, создание и удаление элементов ui в дереве ui
++ `signal` -
 Модификация обработчиков сигналов(подробнее об этом смотрите в описании свойства `signal`, в основной спецификации gui), испускание сигналов элементов ui. Имеет смысл рассматривать этот api как часть ui api
++ `action_object` -
 создание, удаление и модификация `action_object`ов. Этот апи также часть `ui` api.
+ data stack
  сохранение и передача различных данных между секциями code в разных action_objectах, с учётом порождаемых состояний. Выполняет сразу две задачи - хранить некоторые глобальные данные и передача данных от одной секции code к другой(подобно параметрам функций).

Представленные выше виды api имеют соответствующие объекты, к которым имеет доступ javascript код. Фактически, это единственные глобальные api, которые доступны любым участкам кода, встраиваемого в дерево ui. Иными словами, js код не имеет доступа ни к какому контексту, в котором он может исполняться(например доступ к DOM браузера(если исполняется в браузере) или доступ к файлам(если исполняется в node.js))

** Подробное описание api

*** `ui`
 Каждая секция `code` имеет доступ к: 

+ ui - объект корень, в котором содержится интерфейс пользователя. 

+ local.ui. Подмножество `ui`, точнее ссылка на конкретный элемент `ui`, в контексте которого выполняется текущий `action_object`

ui содержит дерево объектов-элементов, которые могут иметь следующиеметоды:

+ id create(ui_definition). Создание элемента из ui описания. Метод существует только у root фрейма.
  
+ add(elem_name, id) - добавление элемента элемента к контейнеру. Существует только у фреймов.

+ id remove() - вытаскивание элемента из контейнера. Существует у всех элементов, кромe root фрейма

+ delete - удаление элемента. Существует у всех элементов, кроме root фрейма.

+ elem_obj get(elem_obj_pattern) - Получает объект, содержащий поля, которые указаны в elem_obj_pattern. 
Есть у всех объектов

+ info get_info - Возвращает информацию о текущем элементе, его характеристиках. Применимо пока только для frame объектов, чтобы узнать разрешение, отношение милиметров к пикселям, профайлы производительности и поддерживаемые операции.  

*** `signal`
  
 Сигнал, а точнее фукнция его испускания, выглядит как метод объекта, но с префиксом emit_
 Например так:

```javascript
 ui('somepanel').emit_on_clicked;
```

*** `action_object`
 Создание action_object в javascript во многом подобна тому, как он описывается в json описании ui. 
 Сначала заполняется объект, например так:
```javascript
var aobj;
aobj.gen = ['msg1', 'msg11_plus'];
aobj.accept = ['msg0'];
aobj.chain = [
                 {
                     'duration' : '10sec', 
                     'actions' : [
                                     {'x' : '+10'}
                                 ]
                 }
             ];  
```
Затем его заставить работать, для этого мы заносим его в дерево ui:
```javascript
ui.something.add('ao_obj1',aobj);
```
В итоге получаем работающий action_object, к тому же находящийся в нужном месте в дереве:
```javascript
ui.something.ao_obj1;
```
Естественно `something` - это всего лишь некоторый элемент дерева, не более, то есть `something` это просто некоторый frame.

*** data stack
    Стек для хранения промежуточных и глобальных данных. Применяется для передачи данным между секциями кода из разных action_objectов, отрабатывающих на разные состояния. Данные могут быть привязаны как к определённому состоянию, так и быть в глобальном стеке.

**** Стек данных сообщения
Допустим у нас есть два action_object:

```javascript
"one" : {
    "type" : "action_object",
    "gen" : ['msg1'],
    "code" : function(ui, msg, stack){
                 var figa_s_maslom = "именно она, даже в кармане!";
                 msg.msg1.push('figa',figa_s_maslom);
             }
},
"two" : {
    "type" : "action_object",
    "accept" : ['msg1'],
    "code" : function(ui, msg, stack){
                 var newlabel;
                 newlabel.text = msg.msg1.figa;
                 ui('label1').set(newlabel);
             }
}
```
ao_one породит состояние state1 и засунет в стек этого состояние объект с именем figa. 
ao_two, реагируя на состояние stat1, получит объект figa и присвоит его значение полю text у label1.
Стек данных сообщения msg1 будет удалён после завершения реагирования всех ao на msg1. То есть после этого, объект data.msg1 не будет существовать.

**** Глобальный стек data

```javascript
"one" : {
    "type" : "action_object",
    "gen" : ['msg2'],
    "code" : function(ui, msg, stack){
                 var figa_s_maslom = "именно она, даже в кармане!"
                 ui('data').push('figa',figa_s_maslom);
             }
},
"two" : {
    "accept" : ['msg2'],
    "code" : function(ui, msg, stack){
                 var newlabel;
                 newlabel.text = ui('data').pop('figa');
                 ui('root.label1').set(newlabel);
             }
}
```
Подобно предыдущему примеру один ao посылает сообщение, но при этом данные засовываются в глобальный стек. И во втором ao по приходу сообщения извлекаются из стека. Метод pop() удаляет данные из глобального стека безвозвратно, однако если его не вызвать, то доступ к этим данным можно будет получить из любого метода code любого ao. Поэтому данный механизм называется глобальным стеком данных. Также можно после pop() засунуть данные обратно с помощью push(name, data). 

**** Стек данных ao

```javascript
"one" : {
   "type" : "action_object",
   "accept" : ['one_create', 'one_toString'],
   "code" : function(ui,msg, stack){
                if (ui('msg').accepted == 'one_create'){
                    stack.push('ya Veselilko');
                } else if ( ui('msg').accepted == 'one_toString'){
                    var txt = stack.pop());
                    msg'.gen('one_toStringReply';
                    msg.one_toStringReply.push('result', txt);
                }
            }
},

"caller" : {
    "type" : "action_object",
    "accept" : ['start_example','one_toStringReply'],
    "code" : function(ui){
        if (msg.accepted == 'start_example'){
            msg.gen('one_create');
            msg.gen('one_toString');      
        } else if (msg.accepted == 'one_toStringReply'){
            var label = ui('main').create(
                                               { 
                                                   "type" : "text", 
                                                   "text" : ui('data.one_toStringReply').pop() 
                                               });
            ui('root.main').add('otvet', label);
       }
    }
}
```
Пример комплексный, поэтому начнём по порядку. Если послать сообщение start_example, откуда-нибудь:), то код в методе code в action_object caller проверит, какое сообщение пришло. И поскольку пришло start_example, то будет сгенерировано два сообщения: one_create и one_toString. Оба сообщения, последовательно поймает action_object one, таким образом отработав два раза, сначала на сообщение one_create, потом на сообщение one_toString.
Отработав на сообщение one_create, метод code внесёт 'ya Veselilko' в стек данных action_object'а one(этот стек данных доступен только методу one.code, но всякий раз, когда его вызывают. Этакое постоянное хранилище данных конкретного action_object, в данном случае action_object one. Но как и глобальный стек данных, этот стек поддерживает методы push и pop. И как следствие, если данные забрать с помощью pop, то их больше не будет в стеке)
Отработав на сообщение one_toString, ao.code вытащит из своего стека данных строку 'ya Veselilko', сгененирует сообщение one_toStringReply и прикрепит к нему вытащенную строку.
Затем caller.code снова отработает, но уже на сообщение one_toStringReply, вытащит из стека данных сообщение строку 'ya Veselilko', создаст во фрейме мейн text с этой строкой. Всё:)
Пример ещё можно отобразить с помощью обычного javascript примерно так:
```javascript
var one = one_create();
main.add(new text(one.toString());
```