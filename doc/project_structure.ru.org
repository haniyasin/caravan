* JSone из чего состоит
  Это набор модулей, загружаемых внутри capsule для обеспечения всех необходимых потребностей приложения.
  Основые части:
** init
   собирает воедино все базовые части, подговаливает их к работе. Необходим для того, чтобы не делать этого
   вручную. Хотя, при желании, все части JSone можно использовать и вручную. Даже сообщения можно посылать
   через mq вручную и саму mq использовать без сервисов. Но такая возможность нужна скорее для расширения,
   чем для повседневного использования. Поэтому обычно приложение перед своей работой запускает init и 
   получает в своё распоряжение всё, что JSone может дать.

** mq
   message queue
   Простейшая система доставки сообщений, построенная на базе capsule/modules/transport. Позволяет посылать
   и принимать сообщения поверх любого транспорта, реализованного в capsule. Каждый принимающи использует
   в качестве адреса uuid. При это принимающий, может реагировать на разные uuid. То есть uuid это не адрес
   принимающего, а адрес сообщения. Адрес принимающего же понимается в рамках capsule/modules/transport и
   явно не виден.  Все видят всех. Маршрутизация происходит через друг друга. То есть
   однажды подключившись, узел не толька отправляет и принимает свои пакеты, но и чужие тоже.
   Итого: для отправки сообщения надо знать uuid, скажем так, порта. А для приёма, надо зарезервировать
   порт с uuid.
   Поскольку uuid генерируются, то вся эта система динамическая и не предполагает, чтобы отправляющие и
   принимающие знали адреса друг друга. Скорее она расчитана на то, чтобы все искали друг друга и 
   приспосабливались

** service_loader
   загрузчик сервисов. Сервисы это специальным образом оформленные commonjs модули. Загружая, 
   service_loader подключает к mq и ваш код общается сервисом через mq посредством proxy объекта, чтобы 
   не работать с mq напрямую. Это необходимо для того, что сервис мог находится в любом окружении, и через
   связь с этим окружением, mq позволяло вашему коду работать с сервисом.
   Сервисы это просто набор методов, принимающих аргументы. Свойства не поддерживаются. Также не
   поддерживается возвращение результата. Вместо этого методы записывают результаты своей работы в стек.
   А уже из этого стека, где нужно, результаты извлекаются. Это позволяет минимизировать обратную связь.
   Подробнее можно почитать об этом в capsule/doc/sprout.org. Поскольку это довольно важная концепция, без
   неё достаточно сложно понять как идёт взаимодейтсвие с сервисами. И уж тем более как реалиализуются вещи
   типа subscribe.

** objects
   Модули JSone, которые используются для построения приложений. На данный момент это в основном ui

** services
   Сервисы, используемые для построения приложений. Основное отличие от предыдущего, то что это сервисы.
   На данный момент там в основном всё, что касается storage.
   Отдельно стоит пояснить почему что-то отнесено к objects, а что-то к services, хотя по использованию
   можно увидеть, что не сильно отличается. В основном тут дело в оверхеде. Оверхед сервисов выше, пока
   это так. А значит сущности, которые вряд ли будут использоваться множеством потребителей или из других
   окружений(например удалённо), скорее должны быть оформлены локально, в виде объектов. Из истории commit'ов
   видно, что ui то был сервисами, то теперь объекты. Возможно, что я таки найду эффективный путь решения
   данной проблемы, очень уж хочется, чтобы все блоки JSone имели гибкость сервисов. Но пока, надо
   воспринимать это так - объекты и сервисы одинаковы с точки зрения назначения, это блоки для приложения,
   но разные с точки зрения гибкости использования
   + объекты существуют только локально, их надо сериализовать и создавать потом заново на основе 
     сериализованного слепка
   + сервисы при некоторых условиях могут менять своё местоположение, сериализуясь, переносясь и
     восстанавливаясь в другом месте, сохраняя свою работоспособность и меняя лишь адрес.
